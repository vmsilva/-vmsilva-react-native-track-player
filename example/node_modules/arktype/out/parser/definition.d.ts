import { type BaseParseContext, type BaseRoot } from "@ark/schema";
import { type anyOrNever, type array, type defined, type equals, type ErrorMessage, type Fn, type ifEmptyObjectLiteral, type objectKindOrDomainOf, type optionalKeyOf, type Primitive, type requiredKeyOf, type show } from "@ark/util";
import type { type } from "../keywords/keywords.ts";
import type { InnerParseResult } from "../scope.ts";
import type { shallowDefaultableMessage, shallowOptionalMessage, validateString } from "./ast/validate.ts";
import { type inferObjectLiteral, type validateObjectLiteral } from "./objectLiteral.ts";
import type { isDefaultable, OptionalPropertyDefinition } from "./property.ts";
import { type BaseCompletions, type inferString } from "./string.ts";
import { type inferTupleExpression, type maybeValidateTupleExpression, type TupleExpression } from "./tupleExpressions.ts";
import { type inferTupleLiteral, type validateTupleLiteral } from "./tupleLiteral.ts";
export declare const parseInnerDefinition: (def: unknown, ctx: BaseParseContext) => InnerParseResult;
export declare const parseObject: (def: object, ctx: BaseParseContext) => BaseRoot;
export type inferDefinition<def, $, args> = [
    def
] extends [anyOrNever] ? def : def extends type.cast<infer t> ? ifEmptyObjectLiteral<def, object, t> : def extends ThunkCast<infer t> ? t : def extends string ? inferString<def, $, args> : def extends array ? inferTuple<def, $, args> : def extends RegExp ? string : def extends object ? inferObjectLiteral<def, $, args> : never;
export type validateDefinition<def, $, args> = null extends undefined ? ErrorMessage<`'strict' or 'strictNullChecks' must be set to true in your tsconfig's 'compilerOptions'`> : [def] extends [anyOrNever] ? def : def extends OptionalPropertyDefinition ? ErrorMessage<shallowOptionalMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<shallowDefaultableMessage> : validateInnerDefinition<def, $, args>;
export type validateInnerDefinition<def, $, args> = [
    def
] extends [Terminal] ? def : def extends string ? validateString<def, $, args> : def extends BadDefinitionType ? ErrorMessage<writeBadDefinitionTypeMessage<objectKindOrDomainOf<def>>> : unknown extends def ? BaseCompletions<$, args> | {} : def extends readonly unknown[] ? validateTuple<def, $, args> : validateObjectLiteral<def, $, args>;
export declare const parseTuple: (def: array, ctx: BaseParseContext) => BaseRoot;
export type validateTuple<def extends array, $, args> = maybeValidateTupleExpression<def, $, args> extends infer result ? result extends null ? validateTupleLiteral<def, $, args> : result : never;
export type inferTuple<def extends array, $, args> = def extends TupleExpression ? inferTupleExpression<def, $, args> : inferTupleLiteral<def, $, args>;
export type validateDeclared<declared, def, $, args> = def extends type.validate<def, $, args> ? validateInference<def, declared, $, args> : type.validate<def, $, args>;
type validateInference<def, declared, $, args> = def extends RegExp | type.cast<unknown> | ThunkCast | TupleExpression ? validateShallowInference<def, declared, $, args> : def extends array ? declared extends array ? {
    [i in keyof declared]: i extends keyof def ? validateInference<def[i], declared[i], $, args> : declared[i];
} : show<declarationMismatch<def, declared, $, args>> : def extends object ? show<{
    [k in requiredKeyOf<declared>]: k extends keyof def ? validateInference<def[k], declared[k], $, args> : declared[k];
} & {
    [k in optionalKeyOf<declared> & string as `${k}?`]: `${k}?` extends (keyof def) ? validateInference<def[`${k}?`], defined<declared[k]>, $, args> : declared[k];
}> : validateShallowInference<def, declared, $, args>;
type validateShallowInference<def, declared, $, args> = equals<inferDefinition<def, $, args>, declared> extends true ? def : show<declarationMismatch<def, declared, $, args>>;
type declarationMismatch<def, declared, $, args> = {
    declared: declared;
    inferred: inferDefinition<def, $, args>;
};
type Terminal = type.cast<unknown> | Fn | RegExp;
export type ThunkCast<t = unknown> = () => type.cast<t>;
type BadDefinitionType = Exclude<Primitive, string>;
export declare const writeBadDefinitionTypeMessage: <actual extends string>(actual: actual) => writeBadDefinitionTypeMessage<actual>;
type writeBadDefinitionTypeMessage<actual extends string> = `Type definitions must be strings or objects (was ${actual})`;
export {};
