"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.run = void 0;
var _nodeWorker_threads = require("node:worker_threads");
var _codegen = _interopRequireDefault(require("../targets/codegen"));
var _commonjs = _interopRequireDefault(require("../targets/commonjs"));
var _custom = _interopRequireDefault(require("../targets/custom"));
var _module2 = _interopRequireDefault(require("../targets/module"));
var _typescript = _interopRequireDefault(require("../targets/typescript"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const targets = {
  commonjs: _commonjs.default,
  module: _module2.default,
  typescript: _typescript.default,
  codegen: _codegen.default,
  custom: _custom.default
};
const run = async (target, {
  report,
  ...data
}) => {
  if (!_nodeWorker_threads.isMainThread) {
    throw new Error('Worker can only be run from the main thread');
  }
  return new Promise((resolve, reject) => {
    const worker = new _nodeWorker_threads.Worker(__filename, {
      workerData: {
        target,
        data
      },
      env: {
        ...process.env,
        FORCE_COLOR: process.stdout.isTTY ? '1' : '0'
      }
    });
    worker.on('message', message => {
      switch (message.type) {
        case 'info':
          report.info(message.message);
          break;
        case 'warn':
          report.warn(message.message);
          break;
        case 'error':
          report.error(message.message);
          break;
        case 'success':
          report.success(message.message);
          break;
      }
    });
    worker.on('error', error => {
      reject(error);
    });
    worker.on('exit', code => {
      if (code !== 0) {
        reject(new Error(`Worker exited with code ${String(code)}`));
      } else {
        resolve();
      }
    });
  });
};
exports.run = run;
if (!_nodeWorker_threads.isMainThread) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-type-assertion
  const {
    target,
    data
  } = _nodeWorker_threads.workerData;
  const report = {
    info: message => _nodeWorker_threads.parentPort?.postMessage({
      type: 'info',
      message
    }),
    warn: message => _nodeWorker_threads.parentPort?.postMessage({
      type: 'warn',
      message
    }),
    error: message => _nodeWorker_threads.parentPort?.postMessage({
      type: 'error',
      message
    }),
    success: message => _nodeWorker_threads.parentPort?.postMessage({
      type: 'success',
      message
    })
  };
  if (target in targets) {
    // @ts-expect-error - typescript doesn't support correlated union types https://github.com/microsoft/TypeScript/issues/30581
    void targets[target]({
      ...data,
      report
    });
  } else {
    throw new Error(`Unknown target: ${target}`);
  }
}
//# sourceMappingURL=workerize.js.map