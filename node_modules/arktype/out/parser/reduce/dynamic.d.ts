import type { BaseParseContext, BaseRoot } from "@ark/schema";
import { type requireKeys } from "@ark/util";
import type { LimitLiteral } from "../../attributes.ts";
import type { ArkTypeScanner } from "../shift/scanner.ts";
import { type BranchOperator, type Comparator, type MinComparator, type OpenLeftBound, type StringifiablePrefixOperator } from "./shared.ts";
type BranchState = {
    prefixes: StringifiablePrefixOperator[];
    leftBound: OpenLeftBound | null;
    intersection: BaseRoot | null;
    union: BaseRoot | null;
    pipe: BaseRoot | null;
};
export type DynamicStateWithRoot = requireKeys<DynamicState, "root">;
export declare class DynamicState {
    root: BaseRoot | undefined;
    branches: BranchState;
    finalizer: ArkTypeScanner.FinalizingLookahead | undefined;
    groups: BranchState[];
    scanner: ArkTypeScanner;
    ctx: BaseParseContext;
    constructor(scanner: ArkTypeScanner, ctx: BaseParseContext);
    error(message: string): never;
    hasRoot(): this is DynamicStateWithRoot;
    setRoot(root: BaseRoot): void;
    unsetRoot(): this["root"];
    constrainRoot(...args: Parameters<BaseRoot<any>["constrain"]>): void;
    finalize(finalizer: ArkTypeScanner.FinalizingLookahead): void;
    reduceLeftBound(limit: LimitLiteral, comparator: Comparator): void;
    finalizeBranches(): void;
    finalizeGroup(): void;
    addPrefix(prefix: StringifiablePrefixOperator): void;
    applyPrefixes(): void;
    pushRootToBranch(token: BranchOperator): void;
    parseUntilFinalizer(): DynamicStateWithRoot;
    parseOperator(this: DynamicStateWithRoot): void;
    parseOperand(): void;
    private assertRangeUnset;
    reduceGroupOpen(): void;
    previousOperator(): MinComparator | StringifiablePrefixOperator | ArkTypeScanner.InfixToken | undefined;
    shiftedByOne(): this;
}
export {};
