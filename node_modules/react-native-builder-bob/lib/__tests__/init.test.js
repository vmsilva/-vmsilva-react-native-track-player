"use strict";

var _vitest = require("vitest");
var _fsExtra = require("fs-extra");
var _mockFs = _interopRequireDefault(require("mock-fs"));
var _mockStdin = require("mock-stdin");
var _nodePath = require("node:path");
var _init = require("../init");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
_vitest.vi.mock('../../package.json', () => ({
  default: {
    name: 'react-native-builder-bob',
    version: '0.5.0'
  }
}));
let io;
const root = '/path/to/library';
const enter = '\x0D';
const waitFor = async callback => {
  const interval = 10;
  let timeout = 50;
  return new Promise((resolve, reject) => {
    const intervalId = setInterval(() => {
      try {
        callback();
        clearInterval(intervalId);
        resolve(undefined);
      } catch (error) {
        if (timeout <= 0) {
          clearInterval(intervalId);
          // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors
          reject(error);
        }
        timeout -= interval;
      }
    }, interval);
  });
};
(0, _vitest.beforeEach)(() => {
  io = (0, _mockStdin.stdin)();
  (0, _mockFs.default)({
    [root]: {
      'package.json': JSON.stringify({
        name: 'library',
        version: '1.0.0'
      }),
      'src': {
        'index.ts': "export default 'hello world';"
      }
    }
  });
});
(0, _vitest.afterEach)(() => {
  io?.restore();
  _mockFs.default.restore();
  _vitest.vi.restoreAllMocks();
});
(0, _vitest.test)('initializes the configuration', async () => {
  const writeMock = _vitest.vi.spyOn(process.stdout, 'write').mockImplementation(() => true);
  process.chdir(root);
  const run = async () => {
    await waitFor(() => {
      const lastCall = writeMock.mock.lastCall;
      if (lastCall == null) {
        throw new Error('No output');
      }
      if (/The working directory is not clean/.test(String(lastCall[0]))) {
        io?.send('y');
      }
    });
    await waitFor(() => {
      (0, _vitest.expect)(writeMock).toHaveBeenLastCalledWith(_vitest.expect.stringMatching('Where are your source files?'));
    });
    io?.send(enter);
    await waitFor(() => {
      (0, _vitest.expect)(writeMock).toHaveBeenLastCalledWith(_vitest.expect.stringMatching('Where do you want to generate the output files?'));
    });
    io?.send(enter);
    await waitFor(() => {
      (0, _vitest.expect)(writeMock).toHaveBeenLastCalledWith(_vitest.expect.stringMatching('Which targets do you want to build?'));
    });
    io?.send(enter);
    await waitFor(() => {
      (0, _vitest.expect)(writeMock).toHaveBeenLastCalledWith(_vitest.expect.stringMatching("You have enabled 'typescript' compilation, but we couldn't find a 'tsconfig.json' in project root"));
    });
    io?.send(enter);
  };
  await Promise.all([run(), (0, _init.init)()]);
  (0, _vitest.expect)(writeMock).toHaveBeenLastCalledWith(_vitest.expect.stringMatching('configured successfully!'));
  (0, _vitest.expect)(await (0, _fsExtra.readFile)((0, _nodePath.join)(root, 'package.json'), 'utf8')).toMatchSnapshot();
  (0, _vitest.expect)(await (0, _fsExtra.readFile)((0, _nodePath.join)(root, 'tsconfig.json'), 'utf8')).toMatchSnapshot();
});
//# sourceMappingURL=init.test.js.map